\documentclass[a4paper,12pt]{article}


\title{Cocotb wiki}
\author{Nahuel Agustin De Brasi Congiusti}
\date{\today}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{caption}
\captionsetup[lstlisting]{labelformat=empty, justification=raggedright, singlelinecheck=false, font=bf}

\lstset{
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue},
	commentstyle=\color{green!50!black},
	stringstyle=\color{orange},
}

\lstdefinelanguage{make}{
	morekeywords={include, ifeq, else, endif},
	sensitive=false,
	morecomment=[l]\#,
	morestring=[b]"
}


\begin{document}


\maketitle

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\newpage

\tableofcontents

\newpage

\section{Introducción}

\subsection{¿Qué es Cocotb?}

Cocotb es un acrónimo de \textbf{Co}routine based \textbf{Co}simulation \textbf{T}est\textbf{b}ench, y constituye una herramienta de código abierto para la verificación de diseños digitales usando Python. Además de las ventajas que ofrece este lenguaje, Cocotb proporciona un framework que permite escribir el código de manera más eficiente y funciona con cualquier diseño de hardware que se pueda simular, ya sea en Verilog, System Verilog, VHDL, etc.

\subsubsection{¿Cómo funciona?}

Un testbench típico de Cocotb no requiere código RTL adicional. El DUT se instancia como toplevel en el simulador y Cocotb genera los estímulos necesarios y monitorea las salidas directamente desde Python. Es importante notar que no se pueden instanciar bloques HDL, por lo que el DUT debe estar completo.

Un test es simplemente una función en Python. En un momento dado, o bien el simulador avanza en el tiempo, o bien se ejecuta el código. Se utiliza la palabra clave \textbf{await} para indicar cuándo se debe devolver el control de la ejecución al simulador.



\newpage

\section{Instalación}

Se brindara una guia rapida para la instalacion, en caso de ampliar consultar

\begin{itemize}
	\item \href{https://docs.cocotb.org/en/stable/install.html#install-prerequisites}{Guia de instalación de Cocotb}
	\item \href{https://www.python.org/downloads/}{Descargar Python}
\end{itemize}

\subsection{Prerequisitos}


\begin{itemize}
	\item Python 3.6+
	\item GNU Make 3+
	\item Simulador Verilog o VHDL simulator, dependiendo del codigo RTL
\end{itemize}

En caso de necesitar instalar python y make se puede utilizar el siguiente comando

\begin{lstlisting}[language=bash]
sudo apt-get install make python3 python3-pip libpython3-dev
\end{lstlisting}

Algunas opciones de simuladores para instalar

\begin{itemize}
	
\item Icarus Verilog (Verilog)
\begin{lstlisting}[language=bash]
sudo apt-get install iverilog
\end{lstlisting}

\item GHDL (VHDL)
\begin{lstlisting}[language=bash]
sudo apt-get install ghdl
\end{lstlisting}

\item Verilator (Verilog)
\begin{lstlisting}[language=bash]
sudo apt-get install verilator
\end{lstlisting}
\end{itemize}

\subsection{Instalacion de cocotb}

Se recomienda ejecutar en un entorno virtual, para eso primero debemos crearlo. Desde el root del proyecto ejecutamos
\begin{lstlisting}[language=bash]
python -m venv venv
\end{lstlisting}

Luego debemos activar este entorno
\begin{lstlisting}[language=bash]
source venv/bin/activate
\end{lstlisting}

Por ultimo instalamos la librería de cocotb
\begin{lstlisting}[language=bash]
pip install cocotb
\end{lstlisting}

\newpage

\section{Escritura de tests}
En este apartado buscaremos explicar como usar cocotb, usaremos ejemplos básicos para facilitar la explicación.

\subsection{Makefile}

El primer paso es la creación del Makefile. Este archivo simplifica el flujo de verificación y se ejecuta solo con el comando \textbf{make}

\begin{lstlisting}[language=make, caption=Makefile, frame=lines]
TOPLEVEL_LANG = verilog # Lenguaje RTL
VERILOG_SOURCES = $(shell pwd)/and.v # Archivos de codigo RTL
TOPLEVEL = and_2 # Nombre del modulo toplevel
MODULE = and_tb # Nombre del archivo Python del testbench

SIM = icarus # Simulador a usar

# Importar reglas de cocotb para simular el DUT con Python
include $(shell cocotb-config --makefiles)/Makefile.sim
\end{lstlisting}


\subsection{Estructura basica del test}

\subsubsection{Imports}


Primero debemos importar la librería y las clases a utilizar, en este caso solo sera \textbf{Timer} que mas adelante explicaremos su función.

\begin{lstlisting}[language=Python, caption=and\_tb.py, frame=lines]
import cocotb
from cocotb.triggers import Timer
\end{lstlisting}

\subsubsection{Definición de la función}

A continuación escribimos el código del test. La primera línea corresponde al \textbf{decorador}  que utilizaremos; en pocas palabras, es un 'agregado' que se aplica a la función para indicarle al framework que se trata de un test de cocotb.

La segunda línea que observamos es la declaración del test. Para esto utilizamos las palabras reservadas \textbf{async def}, que indican que estamos creando una función asíncrona. Que es un tipo de función que puede pausar su ejecución temporalmente mientras espera que ocurra algún evento o se obtenga un resultado, sin bloquear el resto del programa.

En la declaración del test, vemos que recibe como único argumento \textbf{dut}. Este representa, como mencionamos en la introducción, la instanciación del módulo toplevel que estamos verificando.

\begin{lstlisting}[language=Python, caption=and\_tb.py, frame=lines]
@cocotb.test() # Decorador
async def and_tb(dut): # Declaracion del test
	"""Testbench for the AND gate."""
	# Aqui escribiremos el estimulo para la compuerta AND
\end{lstlisting}

\subsubsection{Asignación de valores}
Lo siguiente, como bien indica el ultimo comentario del fragmento de código anterior es generar los estímulos para la compuerta \textbf{and}. Las señales del dut se acceden usando la misma notación (\textbf{.}) utilizada para acceder a los atributos de un objeto.

Para asignar un valor a una señal usaremos la propiedad \textbf{value} y en este caso lo asignaremos de forma directa tal como podemos ver en el fragmento de código a continuación.

\begin{lstlisting}[language=Python, caption=and\_tb.py, frame=lines]
# Test case 1: A = 0, B = 0, Expected output = 0

# Asignacion directa
dut.a_in.value = 0
dut.b_in.value = 0

\end{lstlisting}

\subsubsection{Assert}
Una vez asignados los valores deseados, debemos esperar a que los cambios se apliquen. Para ello utilizamos el \textbf{Timer}, configurado en este caso en un nanosegundo. Observamos también la palabra clave \textbf{await}, mas adelante explicaremos esto.

Por último, debemos verificar que la salida tenga el valor esperado. Para ello usamos la palabra clave \textbf{assert}, que como indica su nombre, afirma que la condición siguiente sea verdadera. Si esta no se cumple, se genera un error en el test. En este caso ambas entradas eran \textbf{0} por lo que la salida deberá ser \textbf{0}.

\begin{lstlisting}[language=Python, caption=and\_tb.py, frame=lines]
	# Espera para que el cambio se aplique
	await Timer(1, units='ns')
	
	# Verificacion de que se cumpla con la salida esperada
	assert dut.q_out.value == 0
\end{lstlisting}

Finalmente para cerrar este ejemplo de la compuerta \textbf{and}, completamos el test para todas las entradas posibles.

\begin{lstlisting}[language=Python, caption=and\_tb.py, frame=lines]
	# Test case 2: A = 0, B = 1, Expected output = 0
	dut.a_in.value = 0
	dut.b_in.value = 1
	await Timer(1, units='ns')
	assert dut.q_out.value == 0
	
	# Test case 3: A = 1, B = 0, Expected output = 0
	dut.a_in.value = 1
	dut.b_in.value = 0
	await Timer(1, units='ns')
	assert dut.q_out.value == 0
	
	# Test case 4: A = 1, B = 1, Expected output = 1
	dut.a_in.value = 1
	dut.b_in.value = 1
	await Timer(1, units='ns')
	assert dut.q_out.value == 1
\end{lstlisting}

\subsubsection{Triggers mas utilizados}
Los triggers se utilizan para indicar al scheduler de cocotb cuándo debe continuar con la ejecución de una corutina. Como mencionamos anteriormente con el \textbf{Timer}, todo trigger debe usarse junto con la palabra clave \textbf{await}. Esto indica un funcionamiento asíncrono: la corutina se pausa durante el tiempo o condición indicada (por ejemplo, un nanosegundo en el test de la compuerta AND), mientras que el simulador sigue ejecutándose internamente, procesando otras señales o incluso otros tests simultáneamente si existieran.

\paragraph{Trigger de tiempo}

\begin{itemize}
	\item \texttt{cocotb.triggers.Timer(time=None, units='step', *, round\_mode=None, time\_ps=None)}
	\\
	Se dispara cuando el tiempo establecido en \texttt{time} fue transcurrido. Las unidades en \texttt{units} pueden ser 'step', 'fs', 'ps', 'ns', 'us', 'ms', 'sec'
\end{itemize}


\paragraph{Triggers de señales}

\begin{itemize}
	\item \texttt{cocotb.triggers.Edge(signal)}
	\\
	Se dispara en cada flanco de la señal.
	
	\item \texttt{cocotb.triggers.RisingEdge(signal)}
	\\
	Se dispara en el flanco positivo de la señal.
	
	\item \texttt{cocotb.triggers.FallingEdge(signal)}
	\\
	Se dispara en el flanco negativo de la señal.
	\\
	\item \texttt{cocotb.triggers.ClockCycles(signal, num\_cycles, rising=True)}\\
	Se dispara luego de un número determinado de ciclos, indicado por \texttt{num\_cycles}.  
	El flanco se ajusta con el parámetro \texttt{rising} que, por defecto, es \texttt{True} (flanco positivo).
\end{itemize}

\subsubsection{Clock}

La clase \texttt{cocotb.clock.Clock} permite generar un reloj con ciclo de trabajo 50:50.  
Se instancia indicando la señal a controlar, el período y las unidades de tiempo.  

Para que el reloj empiece a funcionar, debemos llamar a \texttt{start()} y pasar la coroutine al \texttt{scheduler} de cocotb mediante \texttt{cocotb.start\_soon(clock.start())}. De esta manera el clock es iniciado y no bloquea la ejecucion de la corutina principal que esta corriendo.

En el siguiente test de un flip flop D vemos en uso a \texttt{cocotb.clock.Clock} y a \texttt{cocotb.triggers.RisingEdge(signal)}
\begin{lstlisting}[language=Python, caption=flipflopd\_tb.py, frame=lines]
import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge

@cocotb.test()
async def flipflopD_tb(dut):
	"""Testbench for the FLIP FLOP D."""
	
	# Definimos el clock
	clock = Clock(dut.clk, 10, units='ns')
	
	# Lo iniciamos para que corra en paralelo 
	# con el resto del test
	cocotb.start_soon(clock.start())
	
	dut.rst_in.value = 1
	
	# Se esperan dos ciclos para asegurar el cambio
	await RisingEdge(dut.clk)
	await RisingEdge(dut.clk) 
	assert dut.q_out.value.integer == 0
	
	dut.rst_in.value = 0
	dut.d_in.value = 0
	await RisingEdge(dut.clk)
	await RisingEdge(dut.clk)
	assert dut.q_out.value.integer == 0
	
	dut.d_in.value = 1
	await RisingEdge(dut.clk)
	await RisingEdge(dut.clk)
	assert dut.q_out.value.integer == 1
	
	dut.rst_in.value = 1
	await RisingEdge(dut.clk)
	await RisingEdge(dut.clk)
	assert dut.q_out.value.integer == 0
\end{lstlisting}


\end{document}